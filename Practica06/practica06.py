# -*- coding: utf-8 -*-
"""practica06.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lkdRk9i5GC0XccjHljLnuV1PDvyjOdS5

##Práctica #6. 
Modifique el código Code_09_02.py para realizar la simulación Monte Carlo con un
intervalo de valores para la SNR de 0 a 5 dB y ejecútelo para 1000 y para 100,000 bits.
"""

# ******************************************************************
# Codigo demostrativo Code_09_02.py
# para curso de Comunicaciones Digitales
# ******************************************************************
# Programador: G. Laguna
# Fecha: 10 de junio 2019
# Colaborador: Adriana de la Cruz Peralta
# Fecha: 02 de enero de 2022
# Universidad Automoma Metropolitana

# Unidad Lerma
# ******************************************************************

import numpy as np
import scipy.signal as signal
import matplotlib.pyplot as plt

def rand_normal(m,desv,N):
    """
   rand_normal(m,desv,N) genera una variable aleatoria con distribucion normal
  m: media
  desv: desviacion estandar
  N: numero de muestras
    Regresa:
  C: valor de las muestras aleatorias
    """
    C = np.zeros(N)
    for i in range(N):
        A = np.random.rand(1)
        R = desv * np.sqrt(2 * np.log(1 / (1 - A)))
        T = np.random.rand(1) * 2 * np.pi
        C[i] = m+R*np.cos(T)

    return C

def bin_rand_uniform(N):
    """
   bin_rand_uniform(N) genera una secuencia binaria con distribucion uniforme
  N: numero de muestras
    Regresa:
  s: secuencia de bits con distribucion uniforme
    """
    s = np.zeros(N)
    for i in range(N):
        A = np.random.rand(1)
        if A > 0.5 :
            s[i] = 1
        else:
            s[i] = 0

    return s

def miSimPe_binary_sys(snr_dB, N):
    """
    miSimPe_binary_sys(snr_dB, N) simula comunicacion de un sistema binario y estimar
                                  la probabilidad de error.
    snr_dB: la relacion SNR en dB
    N: numero de muestras para la simulacion Monte Carlo
    Regresa:
    p: la estimacion de la probabilidad de error 
    """

    E = 1 #Energia de las senales binarias
    snr = 10 ** (snr_dB / 10)
    sigma = np.sqrt(E/snr)

    #Generacion de datos binarios:
    s = bin_rand_uniform(N)

    #Ruido aditivo:
    n0 = rand_normal(0, sigma, N)
    n1 = rand_normal(0, sigma, N)

    #Deteccion binaria y conteo de errores:
    errores = 0

    d = np.zeros(N)
    for i in range(N):
        #Salidas de correlacionadores:
        if s[i] == 0:
            r0 = E + n0[i]
            r1 = n1[i]
        else:
            r0 = n0[i]
            r1 = E + n1[i]

        #Detector:
        if r0>r1:
            d[i]=0
        else:
            d[i]=1

        #Conteo de errores:
        if d[i]!=s[i]:
            errores = errores + 1

    #Estimacion de la probabilidad de error:
    p = errores / float(N)
    return p

def n_bits(x):
  N=x #Numero de experimentos de la simulacion Monte Carlo
  snr_in_dB = np.arange(0.0, 6.0, 1.0)

  Pe = np.zeros(len(snr_in_dB))
  for i in range(len(snr_in_dB)):
      Pe[i]=miSimPe_binary_sys(snr_in_dB[i], N)


  # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  # Graficacion:
  # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  plt.semilogy(snr_in_dB,Pe)
  plt.title('Pe para deteccion binaria de simulacion Monte Carlo')
  plt.xlabel('SNR en dB')

  plt.show()

n_bits(100000)